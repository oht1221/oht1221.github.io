---
title: "[이펙티브 자바 요약] item 10 - equalsTo 구현?"
date: 2020-06-16
tags:
  - 이펙티브자바
  - effectivejava
  - equalsTo
---
 이 글은 'Effective Java 3판'(출판사 : 프로그래밍 인사이트, 저자 : Joshua Bloch, 역자 : 개앞맵시(이복연)) 을 읽고 내용을 정리한 글입니다. 문제가 될 시 삭제하겠습니다.
## Item 10 equalsTo를 구현할 때의 규약

 모든 클래스들이 상속하는 Object 클래스의 equals를 클래스 특성에 맞게 잘 재정의 하면 동치성 검사를 포함하는 자바의 여러 API를 손쉽게 사용할 수 있다. (예를 들면 Set과 Map의 key로 사용가능하고, collections의 contains를 쓸 수 있다.) 다만 equals를 구현할 때에는 지켜야할 규약들이 많고(p.53) 이를 지키지 못하면 equals를 활용하는 많은 자바 API 함수들 역시 제대로 동작하지 않게되기 때문에, 제대로 구현하지 못할 것 같으면 차라리 기본적으로 제공되는 Object 클래스의 equalsTo를 재정의하지 않고 사용하는 것이 최선이다. 또한 많은 경우에서 이 기본적인 equals가 잘 동작한다. 

  equals를 구현할 때에는 그 클래스가 불변이든 가변이든 중간에 신뢰할 수 없는 자원이 관여하면 안된다. 예를 들어 java.net.URL의 equals는 주어진 URL과 매핑된 host의 IP주소를 이용해 비교하는데, IP주소 매핑은 수시로 바뀔 수 있으므로 같은 동작에 대해서 다른 결과를 만들어낼 확률이 매우 높다. 이는 **일관성** 조건을 위배하게 된다.

좋은 equals를 구현 방법을 정리하면 아래와 같다.

1. == 연산자를 사용해 입력이 자기 자신의 참조인지(참조값이 같은지) 확인하고 같으면 필드 값 비교 없이 곧바로 true를 반환한다.  이를 통해 성능을 최적화할 수 있다.
2. instanceOf 연산자로 입력이 올바른 타입인지 확인하고 올바르지 않으면 false를 반환한다. 올바른 타입이라 함은 보통은 equals를 정의한 클래스이고 경우에 따라서는 이 클래스가 구현한 특정 인터페이스일 수 있다. 즉, 특정 인터페이스를 구현한 여러 다른 class간 동치성 비교를 할 때가 이 경우이다. Set, List, Map 등의 컬렉션 인터페이스들이 대표적이다.
3. 입력을 올바른 타입으로 형변환한다. (입력은 항상 Object이고 이를 비교하려는 타입으로 알맞게 변경)
4. 입력 객체와 자기 자신의 '핵심' 필드들이 일치하는지 하나식 검사한다.  만약 2단계에서 인터페이스를 사용했다면 값을 직접 사용하지 못하고(인터페이스는 멤버 변수가 없으므로) 값을 참조하는 함수를 메서드를 사용해야한다. float과 double을 제외한 기본타입 값들은 == 연산자로, 객체 참조 타입 필드는 각각 equals로, float과 double 은 특수한 부동소수점 값 때문에 Float과 Double 클래서에 정의된 정적메서드 compare를 사용해야한다.  그리고 필드 값을 비교할 때에는 적절한 순서로 비교하여(다를 가능성이 높은 필드나 비교 하는 값이 싼 필드를 우선적으로 비교하는 등) 최대한 비교 횟수를 줄이면 성능향상에 도움이 된다. 