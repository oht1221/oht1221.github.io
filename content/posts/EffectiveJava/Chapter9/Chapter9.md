---
title: "[이펙티브 자바 요약] Chapter9 - 일반적인 프로그래밍 규약"

date: "2020-07-28"

tags:

- 이펙티브자바

- effectivejava

- 일반적인 프로그래밍 원칙

- chapter9



---

 이 글은 'Effective Java 3판'(출판사 : 프로그래밍 인사이트, 저자 : Joshua Bloch, 역자 : 개앞맵시(이복연)) 을 읽고 내용을 정리한 글입니다. 문제가 될 시 삭제하겠습니다.



## Item 57 : 지역 변수의 범위를 최소화 하자

- 클래스와 멤버의 접근 권한을 최소화하는 것과 비슷한 취지

- 유지 보수성은 높아지고 오류 가능성은 낮아진다

- 가장 강력한 기법은 <strong>가장 처음 쓰일 때 선언하기</strong> 이다.

- <strong>선언과 동시에 초기화해야 한다.</strong> 초기화하기에 정보가 부족하면 선언을 미뤄야한다. Try-catch 문은 예외로, 변수를 초기화하는 과정이 예외를 던질 가능성을 가지고있으면 try 블록 안에 넣어야한다.

- 만약 변수 값을 try 블록 밖에서도 사용해야한다면(비록 정확하게 초기화는 못해도) try 블록 앞에 선언애햐한다.

- 반복 변수를 반복문 종료 이후에도 사용할게 아니면 while문 보다는 for 문을 사용하자. 반복 변수의 유효범위가 반복과 함께 끝나기 때문에 더 안전하다.

- 아래 코드는 범위가 정확히 일치하고 반복에 관여하는 변수 i, n을 for으로 선언하여 반복 때마다 다시 n을 계산해야하는 비용을 없앴다. 

  ```java
  for (int i = 0, n = expensiveComputation(); i < n; i++) {
    ... //i로 무언가 처리
  }

- <strong>메서드를 작게 유지하고 한 가지 기능에 집중하면 지역 변수 범위를 줄일 수 있다.</strong>



## Item 58 : 전통적인 for 문 보다는 for-each 문을 사용하자

- 반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐, 우리에게 필요한 것은 원소들 뿐이다.
- for-each 문(enhanced <strong>for</strong> statement)을 사용하면 반복자와 인덱스 변수의 단점을 제거할 수 있다. 하나의 관용구로 컬렉션, 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지 신경쓰지 않아도 된다.
- for-each 문을 사용하지 못하는 경우도 있는데, 다음과 같다
  - 파괴적 필터링(destructive filtering) : 컬렉션을 순회하면서 선택된 원소를 제거하는 경우에는 반복자의 remove 메서드를 호출해야 한다.
  - 변형(transforming) : 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다. (값만 가져올 것이 아니라 직접 접근)
  - 병렬 반복(parallel iteration) : 여러 컬렉션을 병렬로 순회할 때에는 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

- for-each 문은 Iterable 인터페이스를 구현한 모든 객체라면 무엇이든 순회할 수 있다.

## Item 59 : 라이브러리를 익히고 사용하자

- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과, 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
- 메이저 릴리스마다 주목할 만한 수많은 기능들이 라이브러리에 추가되니 한번 쯤 릴리스 로그들을 읽어볼 만 하다.
- 최소한 <strong> java.lang, java.util, java.io </strong>와 그 하위 패키지들에는 익숙해져야 한다.
- 표준 라이브러리가 불충분하다 판단되면 구글 Guava와 같은 서드 파티 라이브러리도 고려해보자.



## Item 60 : 정확한 답이 필요하면 float과 double은 피하자

- 특히 금융 관련 연산에는 float, double이 맞지 않다. 0.1 혹은 10의 음의 거듭 제곱을 표현할 수 없기 때문이다.

  ``` java
  public static void main(String[] args) {
    double funds = 1.00;
    int itemsBought = 0;
    for (double price = 0.10; funds >= price; price += 0.10) {
      funds -= price;
      itemsBought++;
    }
    System.out.println(itemsBought + "개 구입");
    System.out.println("잔돈(달러):" + funds);
  }
  ```

- 위 코드를 실행하면, 사탕 3개를 구입한 후 잔돈은 0.39999999999999999 달러가 남는 잘못된 결과가 나온다. 이런 문제를 올바로 해결하려면, BigDecimal, int, 혹은 long을 사용해야 한다.

- BigDecimal의 단점은 느리다는 점이다. 아주 큰 값의 계산이 아니라면 int, long으로 대체할 수 있다.



## Item 61 : 박싱된 기본타입 보다는 기본 타입을 사용하자

- 박싱된 기본 타입은 '식별성(identity)'라는 특성을 갖게되는데 이는 기본 타입에는 없다. 달리 말해 박싱된 기본 타입은 같은 값을 가지는 인스턴스라도 다르다고 식별될 수 있다.(다른 객체이기 때문에!)
- 기본 타입의 값은 null일 가능성이 없다.
- 메모리면에서 기본 타입이 효율적이다.
- 기본 타입과 박싱된 기본 타입을 연산에서 동시에 사용하면 오토 박싱, 오토 언박싱 되는 과정에서 많은 오류 가능성을 내포하게 된다.
- 박싱된 기본 타입을 써야하는 경우는 다음과 같다.
  - 컬렉션의 원소, 키, 값(컬렉션은 기본 타입을 담을 수 없으므로)
  - 매개변수화 타입이나 매개변수화 매서드의 타입 변수로는 박싱된 기본 타입을 써야한다. 자바 언어가 타입 매개변수로 기본 타입을 허용하지 않는다.



## Item 62 : 다른 타입이 적절하다면 문자열 사용은 지양하자

- <strong>문자열은 다른 값 타입을 대신하기에 적합하지 않다.</strong>
- 수치형이면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야 한다.
- 적절한 타입이 있다면 그것을 사용하고, 없다면 <strong>새로 만들자</strong>.
- 여러 요소가 혼합된 데이터는 문자열로 표현하지 말고 차라리 전용 클래스를 private 정적 클래스로 만들자.
- 문자열은 권한을 표현하기에도 적절치 않다.



## Item 63 : 문자열 연결은 느리니 주의하자

- 성능을 포기하고싶지 않다면 <strong>String 대신 StringBuilder</strong>를 사용하자.



## Item 64 : 객체는 인터페이스르 사용해 참조하라

- <strong>적합한 인터페이스가 있다면 매개변수 뿐 아니라 반환 값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.</strong>
- 인터페이스 타입으로 선언하면 프로그램이 훨씬 유연해진다.
- 다만 주의할 점은, 원래의 클래스가 인터페이스의 일반 규약 외에 다른 특별한 기능을 제공하며, 주변 코드가 이에 종속되어 동작한다면, 이를 대체할 새로운 클래스도 같은 기능을 제공해야한다. 예컨데 첫 번째 선선의 주변 코드가 LinkedHashSet이 따르는 순서 정책을 가정하고 동작한다면 이를 다른 Set으로 바꿨을 때 문제가 될 수 있다.
- 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.(String이나 BigInteger같은 값 클래스)
- 요약하면, 항상 가능한 가장 <strong>덜 구체적인 클래스 타입을</strong> 사용하자.



## Item 65 : 리플렉션 보다는 인터페이스를 사용하자

- 리플렉션부터 공부하고 차후 정리



## Item 66 : 네티이브 메서드는 신중히 사용하자

- <strong>성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 권장하지 않는다.</strong>
- 네이티브 언어가 메모리 관리 상 안전하지 않으므로, 자바에서 이를 사용하면 같은 취약점을 안고 가게 된다.



## Item 67 : 최적화는 신중히 하자

- 대부분의 경우 최적화가 성능개선으로 이어지지 않는다.

- 성능 << 좋은 구조 이니깐 성능을 취하겠다고 좋은 구조를 파괴하지 말자.
- 잘 짜여진 구조라면 차후 세부 구현을 통해 성능을 개선할 여지가 생긴다.
- 구조가 망가지면 훨씬 더 안좋은 영향이 생긴다.



## Item 68 : 일반적인 명명 규칙을 따르자

- 일반 적인 명명규칙을 잘 따르자! 더 할 말이 없다!

