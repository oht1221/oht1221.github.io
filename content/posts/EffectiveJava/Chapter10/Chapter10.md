---
title: "[이펙티브 자바 요약] Chapter10 - Exception"

date: "2020-08-04"

tags:

- 이펙티브자바

- effectivejava

- 예외

- chapter10

- exception



---

 이 글은 'Effective Java 3판'(출판사 : 프로그래밍 인사이트, 저자 : Joshua Bloch, 역자 : 개앞맵시(이복연)) 을 읽고 내용을 정리한 글입니다. 문제가 될 시 삭제하겠습니다.



## Item 69 : 예외는 진짜 예외 상황에서만 사용하라

- 예외는 진짜 예외 상황에서만 사용해야하지, 아래와 같이 일반적인 흐름 제어용으로 사용하면 <strong>절대로</strong> 안된다.

  ```java
  try {
    int i = 0;
    while(true) {
      range[i++].climb();
    } catch (ArrayIndexOutOfBoundException e) {
      //예외 처리
    }
  }
  ```

- API 설계에서도 위와 같은 원칙은 그대로 적용되는데, API 설계자는 클라이언트가 일반적인 흐름 제어용으로 예외를 사용할 일이 없게 해야한다. 만약 특정 상태에서만 호출할 수 있는 메서드라면, 클라이언트가 그 상태를 만족하지 못했을 때 터지는 예외를 사용해서 흐름 제어를 할수 있게 하면 안된다. 이 경우 미리 상태를 검사할 수 있는 메서드를 제공해야하는데, 대표적인 예로 Iterator 인터페이스의 next와 hasNext 메서드가 있다.

- 올바르지 않은 상태일 때 상태 검사 메서드 대신 사용할 수 있는 방법으로는 빈 Optional이나 null 같은 특수한 값을 리턴하는 것이 있다.

  

## Item 70 : 복구할 수 있는 예외는 검사 예외를, 그렇지 않으면 비검사 예외를 사용하자

- 자바에서 문제 상황을 알리는 Throwable 타입으로는 검사 예외(Exception), 런타임 예외(RuntimeException), 에러(Error)가 있다.

- 호출하는 쪽에서 복구할 것이라 기대되면 검사 예외를 사용한다. 이 경우 호출하는 쪽의 catch 블록에서 처리를 하던, 바깥으로 던지던 해야한다.

- 런타임 예외와 에러는 비검사 throwable로 묶을 수 있는데, 이 둘은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이기 때문에 잡지 않는 것이 좋다.

- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자. 대부분 전제조건을 만족하지 못했을 때 발생한다.

- 에러는 JVM이 어떤 이유로 더 이상 수행을 계속할 수 없는 상황을 나타낸다. 예를 들면 자원 부족, 불변식 깨짐 등이 있다. Error는 상속해서 다른 하위 클래스를 만들지 마라. 즉, 자체적으로 구현한 비검사 throwable은 모두 RuntimeException을 상속한(확장한) 것이어야 한다.

- 위 세 가지 외 throwable 상속해서 또 다른 예외 상황을 <strong>만들지 마라</strong>.

- 검사 예외는 보통 복구 가능한 경우에 발생하므로, 메서드를 호출한 쪽에서 사용할 수 있는 정보를 알려주는 메서드를 제공하는 것이 중요하다.(아니면 메시지 파싱해서 사용해야함)

  

## Item 71 : 필요 없는 검사 예외는 사용하지 마라

- 검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높이게끔 해주지만, 명시한 검사 예외는 꼭 처리하거나 바깥으로 던져줘야하는 만큼 API 사용의 부담이 커진다. 더구나 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용이 안된다.

- API를 제대로 사용해도 발생할 수 있는 예외이거나 프로그래머가 의미있게 조치를 취할 수있는 예외가 아니라면 비검사 예외를 던지는 것이 좋다. 예를 들어,

  ``` java
  } catch (TheCheckedError e) {
    throw new AssertionError();
  }
  ```

  이나,

  ```java
  } catch (TheCheckedError e) {
    e.printStackTrace();
    System.exit(1);
  }
  ```

  외에 처리할 방법이 없다면 비검사 예외를 던져야한다.

- 검사 예외를 피하는 방법에는 대표적으로 두 가지가 있다.

  - 적절한 결과 타입을 담은 Optional을 반환하는 것이다. 검사 예외를 던지는 대신 단순히 빈 Optional을 반환하면 된다. 단, 예외 정보를 담을 수가 없어지는 단점이 있다.

  - 검사 예외를 던지는 메서드를 2개로 쪼개서 비검사 예외로 바꿀 수 있다. 예를 들면,

    ``` java
    try {
      obj.action(args);
    } catch (TheCheckedException e) {
      ... // 검사 예외 처리
    }
    ```

    를 다음과 같이 리팩터링 할 수 있다.

    ```java
    if (obj.actionPermitted()) {
      obj.action(args);
    }
    else {
      // 예외 상황 처리
    }
    ```

    이 방식이 무조건 아름다운 것은 아니지만, 최소한 더 유연한 API로 만들어 줄 수는 있다. 만약 프로그래머가 이 메서드가 확실히 성공할 것을 알거나 실패 시 스레드가 종료되길 원한다면, 그냥

    ```java
    obj.action(args);
    ```

    와 같이 써도 된다.

    

## Item 72 : 표준 예외를 사용하라

- 표준 예외를 사용하면 여러 장점이 있다.

  - 내 API를 남들이 익히기 쉬워진다.
  - API를 사용한 프로그램도 읽기 쉬워진다.
  - 예외 클래스가 적어 메모리도 적게 사용하고 클래스 로딩 시간도 줄어든다.

- 자주 재사용 되는 예외들을 익히자

  - IllegalArgumentException : 허용하지 않는 값이 인수로 건내졌을 때(null은 따로 NullPointerException으로 처리)

  - IllegalStateException : 객체가 메서드를 수행할 수 없는 상태일 때

  - NullPointerException : null을 허용하지 않는 메서드에 null을 건넸을 때

  - IndexOutOfBoundException : 인덱스가 범위를 넘어섰을 때

  - ConcurrentModificationException : 허용하지 않는 동시 수정이 '발견'됐을 때(실제 발생하는 순간을 포착하는 안정된 방법은 없음)

  - UnsupportedOperationException : 호출한 메서드를 지원하지 않을 때

    

## Item 73 : 추상화 수준에 맞는 예외를 터뜨려라

- 간혹 수행하려는 일과 관련 없는 예외가 나와 당황스러운 경우가 있는데, 이는 내부에서 동작하는 로직이 저수준 예외를 처리하지 않고 바깥으로 전파했을 때 나타나는 현상이다. 

- 저수준 예외를 바깥으로 보내면 프로그래머가 당황하는 문제도 생기지만, 그보다도 내부 구현이 바깥으로 드러나서 상위 레벨 API를 오염시키게 된다. 만약 다음 릴리스에서 내부 구현이 바뀌면, 바뀌기 전 예외를 처리하도록 한 API 사용 프로그램을 망가뜨릴 수 있다.

- 상위 계층에서는 예외를 그 단계에서 처리하지 않고 바깥으로 던질거라면, 저수준 예외를 잡아 자신의 추상화 레벨에 맞는 예외로 바꿔서 던져야 한다. 이를 예외 번역(exception translation) 이라고 한다.

  ``` java
  try {
    ...
  }
  catch (LowerLvException e) {
    throws new HigherLvException(...);
  }
  ```

- 예외 번역 시에 저수준 예외가 디버깅에 도움이 된다면 그 저수준 예외를 고수준 예외에 실어 보낼 수도 있는데 이를 예외 연쇄(exception chaining)라고 한다. 이 저수준 예외는 별도의 접근자 메서드(Throwable의 getCause 메서드)를 통해 필요한 경우 꺼내 쓸 수 있다.

- 무턱대고 예외를 전파하는 것 보다는 예외 번역이 좋은 방법이긴 하지만 이도 남용하는 것은 곤란하다. 가장 좋은 것은 아래 계층에서 예외가 나지 않도록 하는 것이다. 때로는 상위 계층 메서드의 매개 변수를 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이를 달성할 수 있다. 

- 아래 계층에서의 예외를 피할 수 없다면 상위 계층에서 이를 조용히 처리하여 실제 API 사용자는 이를 모르게 할 수 있다. 이 경우 발생한 예외는 적절한 로깅 기능으로 기록해두면 좋다.



## Item 74 : 메서드가 던지는 모든 예외를 문서화 하자

- 메서드가 던지는 예외는 메서드를 올바로 사용하기 위한 아주 중요한 정보이기 때문에 하나하를 문서화해야한다.

- <strong>검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화 하자.</strong> 다시 말해, 상위 Exception 클래스로 뭉뚱그려 선언하면 안된다. 따가 하나의 예외는 main 함수로, main은 JVM만 실행하고 클라이언트가 사용할 일이 없기 때문이다.

- 비검사 예외도 문서화 해두면 좋다. 오류를 일으킬 가능성이 있는 부분을 명시해주면 자연스럽게 오류가 나지 않도록 코딩할 수 있다.

- 메서드가 던질 수 있는 예외를 @throws 태그로 잘 문서화하되, 비검사 예외는 메서드의 throws 목록에서는 제외하자. 비검사 예외가 발생한 경우와 검사 예외가 발생한 경우 API 사용자가 해야할 일이 달라지기 때문에 둘을 확실히 구분하는 것이 좋다. javadoc은 @throws와 throws에 모두 포함된 예외와 @throws에만 포함된 예외를 구분해서 표시해준다.

- 만약 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 터뜨린다면 그 예외를 클래스 설명에 추가하는 방법도 있다.(메서드 별로 다 쓰지 말고) NullPointerException이 가장 대표적이다.

  

## Item 75 : 예외의 상세 메세지에 실패 관련 정보를 담자

- 사후 분석을 위해 실패 순간의 상황을 예외의 상세 메시지에 상세히 담아줘야한다. 특히 재현하기 힘든 경우 더욱 더 중요하다.

- 순패 순간을 제대로 포착하려면 실패 순간에 관여한 모든 매개변수와 필드 값을 실패 메세지에 담아야한다. 예를 들어 ArrayIndexOutOfBoundException의 경우 인덱스의 최솟값, 최댓값, 실제 들어온 인덱스 값을 모두 포함해야하는 식이다.

- 실패에 관여한 모든 데이터를 담아야하지만, 장황할 필요는 없다. 굳이 소스코드와 스택 트레이스에서 찾을 수 있는 정보는 담을 필요가 없다.

- 예외 상세 메세지와 최종 사용자가 볼 오류 메세지를 착각하면 안된다. 예외 상세 메세지는 개발자가 참고할 정보만 명료하게 담는 것이고, 오류 메세지는 가독성을 고려하여 친절하게 작성하면 된다.

- 예외는 실패와 관련된 정보를 얻을 수 있는 접근자 메서드를(get~) 제공해야 예외 발생 시 복구 코드를 작성하기 용이하다. 접근자 메서드가 없으면 메시세지를 다시 파싱해서 값을 찾아야하는 상황이 발생한다.

  

## Item 76 : 실패는 가능한한 원자적으로 만들자

- 호출된 메서드가 실패해도, <strong> 해당 객체는 메서드 호출 전 상태를 유지해야한다.</strong> 이러한 특성을 '실패 원자적(failure-atomic)'이라고 한다.

- 가장 쉽게 실패 원자적으로 만드는 방법은 태생적으로 실패 원자적인 불변 객체를 만드는 것이다. 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않는다.

- 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은, 메서드의 본 기능 실행 전에 매개 변수의 유효성을 검사하는 것이다. 

  ```java
  public Object pop() {
    if (size == 0) {
      throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
  }
  ```

- 위 메서드 시작 부분의 if 절에서 size의 값을 확인하여 0이면 예외를 던지게 돼있는데, 꼭 이 처리를 해주지 않아도 스택이 비어있으면ArrayIndexOutOfBoundException이 터지지만, 음수 값으로 변경된 size 값이 복구 되지 않은 상태로 다음 호출이 이어지기 때문에 다음번 호출도 실패하게 만들고 또 예외의 추상화 수준도 상황에 어울리지 않는다.

- 위와 비슷한 방법으로, 예외 가능성이 있는 코드를 메서드이 상태 변화 코드에 앞에 배치하는 방법이 있다.

- 실패 원자성을 확보하는 세 번째 방법은, 객체의 임시 복사본에서 작업을 수행한 다음 작업이 성공적으로 완료되면 원래 객체와 교체하는 것이다. 데이터를 임시 자료구조에 저장해 작업하는 것이 빠를 때 적용하기 좋은데, 예를 들어 정렬 시 배열에 옮겨 정렬 후 원래 객체에 옮기는 방법이 있다. 이러면 정렬 속도에서도 이득을 볼 수 있고(배열에서의 원소 접근 속도가 더 빠르기 때문에), 실패하더라도 원래 객체에는 아무런 변화가 없다.

- 마지막 방법은 실패를 가로채는 복구 코드를 작성하는 방법인데, 널리 쓰이지는 않는다. 주로 디스크 기반의 내구성을 보장해야하는 경우 쓰인다.

- 실패 원자성은 항상 달성할 수 있는 것은 아닌데, 예를 들면 멀티 스레드 환경에서 한 변수에 동시에 쓰기가 실행되면 객체 일관성이 깨지고, ConcurrentModificationException이 터지더라도 그 객체가 여전히 사용가능한 상태라고 생각하면 안된다.(실패 원자성이 보장되지 않음)

- Error는 어차피 복구 못하니까 실패 원자적으로 만들 필요도 없다.

- 실패 원자성을 달성하기 위한 비용이나 복잡도가 너무 큰 경우, 꼭 실패 원자성을 확보해야하는 것은 아니다.

- 메서드 명세에 기술한 예외라면 실패 원자성이 보장돼야하는 것이 원칙이며 이것을 지키지 못하면 메서드 명세에 실패 시 객체 상태를 명시해줘야 한다.

## Item 77 : 예외를 무시하지 말라 

- API 설계자가 메서드 선언에 예외를 명시하는 이유는 <strong>그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다.</strong>
- 사실 catch 블록을 비워두기만 하면 예외는 가볍게 무시가 되는데, <strong>catch 블록을 비워두면 예외가 존재할 이유가 없다!</strong>
- 예외를 무시해야하는 경우도 있는데, 가령 FileInputStream 을 닫는 경우에는 입력 전용 스트림이므로 파일의 상태를 변경하지 않았으니 예외가 발생해도 복구할 것이 없으며, 스트림을 닫는 다는 것은 이미 읽을 내용은 다 읽었다는 뜻이기 때문에 남은 작업을 중단할 이유도 없다(try-catch블록으로 안 감싸면 남은 작업이 중단됨). 이런 경우에도, 예외를 무시하기로 했으면 catch 블록 안에 그 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔주는 것이 좋다.
- 무시하지 않고 차라리 바깥으로 전파되도록 두기만 해도 최소한 디버깅 정보를 남긴 채 프로그램이 중단되게 할 수는 있다.

