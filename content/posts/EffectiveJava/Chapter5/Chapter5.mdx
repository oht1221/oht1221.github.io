---
title: "[이펙티브 자바 요약] Chapter5 - 제네릭"
date: 2020-06-30
tags:
  - 이펙티브자바
  - effectivejava
  - generic
  - chapter5
---
 이 글은 'Effective Java 3판'(출판사 : 프로그래밍 인사이트, 저자 : Joshua Bloch, 역자 : 개앞맵시(이복연)) 을 읽고 내용을 정리한 글입니다. 문제가 될 시 삭제하겠습니다.
## Item 26 
 Raw type을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안된다. Raw type은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공되는 것일 뿐 사용을 권장하지 않는다. 예를 들면 Object의 Set이나, Set<?> 등은 사용 가능하지만, Set만으로 객체를 선언하는 것은 안전하지 않다. Object의 Set은 어떤 것도 받아들일 수 있는 parameterized type이고 Set<?>은 특정한 (아직 정해지지 않은) 타입의 객체 하나만 받아들일 수 있다.
## Item 27 비검사 경고 제거
 비검사 경고는 남겨두지 말자. 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 가능성을 가지고 있다. 경고를 없앨 방법이 없다고 생각되면, 그 코드가 타입 안전한지 증명해보고 가능한 좁은 범위에서 @SuppressWarnings("unchecked") annotaion으로 경고를 없애자. 그리고 그렇게 처리한 근거를 comment으로 남겨야한다.
## Item 28 배열보다는 리스트를 사용하자
 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 covariant, 즉 상위 타입 A의 배열은 하위 타입 B의 배열의 상위 타입이고 또 실체화가 가능하다. 하지만 제네릭은 그 invariant로 예를 들어 상위 타입 A의 Set은 하위 타입 B의 Set과 상/하위 관계가 없다.(타입 정보가 소거됨). 그 결과 배열은 런타임에서는 안전하지만 컴파일 타임에서는 그렇지 않다. 제네릭은 그 반대의 성질을 갖는다. 따라서 둘을 섞어 쓰는 것은 쉽지 않으므로 둘을 섞어 쓰다가 컴파일 에러나 오류를 만나면 먼저 배열을 리스트로 대체해보자.
## Item 29 이왕이면 제네릭 타입
 클라이언트에서 직접 형변환해야 하는 타입보다는 제네릭 타입이 더 안전하고 쓰기 편하다. 따라서 새로운 타입을 설계할 때는 형변환이 필요 없이 사용할 수 있게 하는 것이 좋다. 그렇게 하려면 보통 제네릭 타입으로 만들어야 하는 경우가 생긴다. 기존 타입 중에서 제네릭이었어야 더 편리할 경우가 있다면 제네릭으로 변경해보자. 
## Item 30 이왕이면 제네릭 메써드로!
 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다는 제네릭 메서드가 더 안전하고 사용하기도 쉽다. 타입과 마찬가지로 메서드도 형변환 없이 사용할수 있는 편이 좋으며 많은 경우 그렇게 하려면 제니릭 메서드가 돼야한다.
## Item 31 한정적 와일드카드를 사용해 API 유연성을 높이자!
 조금 복잡하더라도 와일드 카드 타입을 적용하면 API가 유연해진다. 따라서 널리 쓰일 라이브러리를 설계한다면 반드시 와일드카드 타입을 적절하게 사용해줘야한다. producer는 extends, consumer는 super 를 기억하자! 
## Item 32 제네릭과 가변인수를 함께 사용할 때에는 신중!
 가변 인수와 제네릭은 같이 사용하지 않는 편이 좋다. 가변인수 기능은 배열이 노출되어 추상화에 좋지 않고, 배열과 제네릭의 타입 규칙 이 서로 다르기 때문이다. 제니릭 varargs 매개변수는 타입 안전하지는 않지만 사용은 가능한다. 메서드에 제네릭 (혹은 parameterized된) varargs 매개변수를 사용하고자 한다면 먼저 그 메서드가 타입 안전한지 확인하고, @SafeVarargs 에너테이션을 달자.
 ## Item 33